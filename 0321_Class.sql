/*0321 Class*/

-- 레코드 그룹별 집계 : GROUP BY
-- 집계 조건 : HAVING 
-- 집합을 받아서 하나의 값으로 모아주는 '집계함수'

SELECT
	SUM(e.SAL) AS sum_of_sal
,
	AVG(e.SAL) AS avg_of_sal
FROM
	EMP e;

-- DISTINCT 키워드 (UNIQUE)  :: 중복제거
SELECT
	DISTINCT deptno
FROM
	emp;

SELECT
	DISTINCT e.DEPTNO,
	e.SAL,
	e.EMPNO
FROM
	EMP e;

SELECT SAL FROM EMP;
SELECT
	DISTINCT SAL
FROM
	EMP;
SELECT SUM(DISTINCT e.SAL) AS sum_of_distinct
	, SUM(ALL e.SAL) AS sum_of_all
	, SUM(e.SAL) AS normal_sum
FROM EMP e;

-- 부서별 최고 연봉자와 최소 연봉자의 SAL은 몇배가 차이날까?
SELECT
	max(sal) AS max_sal
	,
	min(sal) AS min_sal
	,
	round(max(sal) / min(sal), 1) AS max_min_times
FROM
	EMP
WHERE
	deptno = 30
;

/*
 * COUNT 집계 함수 
 */
SELECT
	COUNT(EMPNO),
	COUNT(COMM)
FROM
	EMP;  
-- 집계함수에서는 NULL을 무시하고 진행, 0은 포함

SELECT
	COUNT(*)
FROM
	EMP
WHERE
	DEPTNO = 30;
-- COUNT(*)에서만 NULL을 포함한다**


--ALL 합계는 *와 같이 NULL을 포함
SELECT COUNT(DISTINCT SAL)
	, COUNT(ALL SAL)
	, COUNT(SAL) 
FROM EMP;

SELECT COUNT(ENAME)
FROM EMP
WHERE NVL(COMM, 0) > 0
;


-- 부서별 UNION ALL을 이용한 무식한 집계 방법
SELECT
	AVG(SAL),
	'10' AS DNO
FROM
	EMP
WHERE
	DEPTNO = 10
UNION ALL
SELECT
	AVG(SAL),
	'20' AS DNO
FROM
	EMP
WHERE
	DEPTNO = 20
UNION ALL
SELECT
	AVG(SAL),
	'30' AS DNO
FROM
	EMP
WHERE
	DEPTNO = 30
;

--GROUP BY 키워드를 사용하여 스마트하게 집계
SELECT
	DEPTNO,
	JOB,
	COUNT(SAL) ,
	AVG(SAL + NVL(COMM, 0)) AS AVG_PAY,
	MAX(SAL + NVL(COMM, 0)) AS MAX_PAY,
	MIN(SAL + NVL(COMM, 0)) AS MIN_PAY,
	SUM(SAL + NVL(COMM, 0)) AS SUM_PAY
FROM
	EMP
GROUP BY
	DEPTNO,
	JOB
ORDER BY
	DEPTNO 
;

-- JOIN 키워드 : 테이블 정규화로 분할된 테이블 칼럼을 다시 합치는 작업
SELECT
	*
FROM
	EMP,
	DEPT
ORDER BY
	EMPNO;
-- 두 테이블이 가로로 붙게 되지요? 그런데 중복이 엄청나네요. DEPTNO가 동일할 때 DEPT정보가 붙지 않고 EMP마다 모든 DEPTNO의 정보가 붙여버림
-- JOIN조건이 없는 경우에 발생되는 중복곱(CARTESIAN PRODUCT)

SELECT
	*
FROM
	EMP e,
	DEPT d
	-- 잘못된 JOIN 사용
WHERE
	e.NAME = 'SMITH'
ORDER BY
	e.EMPNO
;

-- 교집합 조인(INNER JOIN) 적용 (WHERE 절에 조건 작성)
SELECT
	*
FROM
	EMP e,
	DEPT d
WHERE
	e.DEPTNO = d.DEPTNO    -- 오라클 PL/SQL 문법
ORDER BY
	EMPNO
;

--JOIN-ON으로 등가 조인(INNER JOIN) :: ON 절에 JOIN 조건 작성
SELECT
	*
FROM
	EMP e
JOIN DEPT d 
ON
	e.DEPTNO = d.DEPTNO  	-- 표준SQL문법, 괄호 삭제해도 괜춘
ORDER BY
	EMPNO
;

--USING 구문 활용   :: ON 대신 USING절에 조건, 조인할 값 입력
SELECT
	e.EMPNO ,
	e.HIREDATE ,
	d.DNAME ,
	e.JOB ,
	e.SAL
FROM
	EMP e
JOIN DEPT d
		USING (DEPTNO)  	-- 표준SQL문법 , USING절은 괄호 삭제하면 안 됨
ORDER BY
	e.EMPNO
;

/*
 * 자바, C/C++ 등 프로그래밍에서 SQL 쿼리문 사용하는 경우 쿼리문을 문자열로 사용 가능
 */
var_sql = "SELECT E.EMPNO
		, e.HREDATE
		, d.DNAME
		, e.JOB 
		, e.SAL
FROM EMP E JOIN DEPT D
ON E.{VAR_DEPTNO} = D.{VAR_DEPTNO}
"

SELECT
	e.EMPNO,
	e.HIREDATE,
	TO_CHAR(e.HIREDATE, 'YYYY, MM-DD') AS Hire_ymd,
	e.ENAME,
	d.DEPTNO ,
	d.LOC
FROM
	EMP e ,
	DEPT d
WHERE
	e.DEPTNO = d.DEPTNO
ORDER BY
	d.DEPTNO,
	e.EMPNO
;

SELECT
	e.EMPNO,
	e.HIREDATE,
	TO_CHAR(e.HIREDATE, 'YYYY, MM-DD') AS Hire_ymd,
	e.ENAME,
	d.DEPTNO ,
	d.LOC,
	e.SAL
FROM
	EMP e ,
	DEPT d
WHERE
	e.DEPTNO = d.DEPTNO AND e.SAL < 2000
ORDER BY
	d.DEPTNO,
	e.EMPNO
;

SELECT d.DNAME AS dname, e.JOB AS JOB, 
	ROUND(AVG(e.SAL), 0) AS AVG_SAL,
	SUM(e.SAL) AS SUM_SAL,
	MIN(e.SAL) AS MIN_SAL,
	MAX(e.SAL) AS MAX_SAL,
	COUNT(e.SAL) AS CNT_SAL 
FROM EMP e, DEPT d
WHERE e.DEPTNO = d.DEPTNO AND e.SAL < 2000
GROUP BY d.DNAME, e.JOB
;

-- SALGRADE 테이블과 JOIN하여 사잇값 추출
SELECT
	e.ENAME ,
	s.GRADE,
	e.SAL ,
	s.LOSAL ,
	s.HISAL
FROM
	EMP e ,
	SALGRADE s
WHERE
	e.SAL BETWEEN s.LOSAL AND s.HISAL
;

-- GRADE별 직원 수 추출
SELECT
	s.GRADE ,
	COUNT(e.ENAME) AS emp_cnt
FROM
	EMP e ,
	SALGRADE s
WHERE
	e.SAL BETWEEN s.LOSAL AND s.HISAL
GROUP BY
	s.GRADE
ORDER BY
	emp_cnt DESC 
;

SELECT *
FROM EMP e , DEPT d      -- 내가 필요한 테이블과 별칭 지정
WHERE e.DEPTNO = d.DEPTNO  -- INNER JOIN
;

/*
 * SELF-JOIN(자체 조인) 자기 자신의 릴레이션을 이용해서 테이블 컬럼을 조작
 */

-- 
SELECT
	E1.EMPNO ,
	E1.ENAME ,
	E1.MGR ,     -- 해당 EMPLOYEE의 매니저 넘버
	E2.EMPNO AS MANAGER_EMPNO,   -- E2로 EMPNO를 통해서
	E2.ENAME AS MANAGER_ENAME       -- 매니저의 이름을 가져오자
FROM						 -- SELF-JOIN을 목적으로 테이블
	EMP e1,
	EMP e2
WHERE
	E1.MGR = E2.EMPNO 
; -- ㅡMGR값이 NULL인 KING이 사라짐. 해당없으니 나타나지 않은 것.

-- LEFT-JOIN ::  (+)활용
SELECT
	E1.EMPNO ,
	E1.ENAME ,
	E1.MGR ,
	E2.EMPNO AS MGR_NO,
	E2.ENAME AS MGR_ENAME
FROM
	EMP e1,
	EMP e2
WHERE
	E1.MGR = E2.EMPNO(+)    -- MGR이 기준인 LEFT-JOIN  :: MGR이 EMPNO와 교집합이 없으면 NULL값을 내보냄.
ORDER BY
	E1.EMPNO
; -- 해당 없는 값(MGR=EMPNO가 아닌 값)을 NULL로 표시해줌

SELECT
	E1.EMPNO ,
	E1.ENAME ,
	E1.MGR ,
	E2.EMPNO AS MGR_NO,
	E2.ENAME AS MGR_ENAME
FROM
	EMP e1
LEFT OUTER JOIN EMP e2 
	ON
	E1.MGR = E2.EMPNO
;

-- RIGHT-JOIN : 오라클 SQL 활용   (+)붙이기
-- 상사(MGR)가 있는 경우에 해당 직원을 출력하는 경우다. NULL같은 아래직원이 없는 경우임
SELECT
	E1.EMPNO ,
	E1.ENAME ,
	E1.MGR ,
	E2.EMPNO AS MGR_NO,
	E2.ENAME AS MGR_ENAME
FROM EMP e1, EMP e2
WHERE E1.MGR(+) = E2.EMPNO      --RIGHT-JOIN 
; 

-- 표준 SQL로 RIGHT-OUTER-JOIN 출력
SELECT
	E1.EMPNO ,
	E1.ENAME ,
	E1.MGR ,
	E2.EMPNO AS MGR_NO,
	E2.ENAME AS MGR_ENAME
FROM EMP E1 RIGHT OUTER JOIN EMP E2
		ON E1.MGR = E2.EMPNO 
;

-- 양측 조인 FULL-OUTER-JOIN 
SELECT 	
	E1.EMPNO ,
	E1.ENAME ,
	E1.MGR ,
	E2.EMPNO AS MGR_NO,
	E2.ENAME AS MGR_ENAME
FROM EMP e1 FULL OUTER JOIN EMP e2
		ON (E1.MGR=E2.EMPNO)
		ORDER BY E1.EMPNO
;

-- EMP, DEPT, SALGRADE, EMP   :: SELF-JOIN
-- 4개의 테이블을 활용하여 값을 출력
SELECT
	D.DEPTNO ,
	D.DNAME	,
	E1.EMPNO	,
	E1.ENAME	,
	E1.MGR 	,
	E1.SAL 	,
	E1.DEPTNO	,
	S.LOSAL 	,
	S.HISAL 	,
	S.GRADE 	,
	E2.EMPNO AS MGR_EMPNO	,
	E2.ENAME AS MGR_ENAME
FROM
	EMP e1 ,
	DEPT d ,
	SALGRADE s ,
	EMP e2
WHERE
	E1.DEPTNO(+) = D.DEPTNO
	AND E1.SAL BETWEEN S.LOSAL AND S.HISAL
	AND E1.MGR = E2.EMPNO
ORDER BY
	D.DEPTNO,
	E2.EMPNO
;
-- 2씩 연관 테이블의 일부를 오라클 SQL로 값을 출력
SELECT
	D.DEPTNO ,
	D.DNAME ,
	E1.EMPNO ,
	E1.ENAME ,
	E1.MGR ,
	E1.SAL
FROM
	EMP e1,
	DEPT d,
	SALGRADE s ,
	EMP e2
WHERE
	E1.DEPTNO(+) = D.DEPTNO   --(+)가 있을 땐 OPERATIONS 부서가 나오고, 없을 땐 안나오죠
	AND E1.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+)    -- FULL OUTER JOIN 아니구요
	AND E1.MGR = E2.EMPNO(+)
;

SELECT
	D.DEPTNO ,
	D.DNAME ,
	E1.EMPNO ,
	E1.ENAME ,
	E1.MGR ,
	E1.SAL ,
	E1.DEPTNO ,
	S.LOSAL ,
	S.HISAL ,
	S.GRADE
FROM
	EMP e1,
	SALGRADE s ,
WHERE
	E1.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+)    -- FULL OUTER JOIN 아니구요
;


SELECT
	E1.EMPNO ,
	E1.ENAME ,
	E1.MGR ,
	E1.SAL ,
	E2.EMPNO AS MGR_NO ,
	E2.ENAME AS MGR_NAME
FROM
	EMP e1 ,
	EMP e2
WHERE
	E1.MGR = E2.EMPNO(+)
;

SELECT
	D.DEPTNO ,
	D.DNAME ,
	E1.EMPNO ,
	E1.ENAME ,
	E1.MGR ,
	E1.SAL ,
	E1.DEPTNO ,
	S.LOSAL ,
	S.HISAL ,
	S.GRADE ,
	E2.EMPNO AS MGR_EMPNO ,
	E2.ENAME AS MGR_ENAME
FROM
	EMP e1
RIGHT JOIN DEPT d 
	ON
	e1.DEPTNO = d.DEPTNO
LEFT OUTER JOIN SALGRADE s 
	ON
	(E1.SAL >= s.LOSAL
		AND e1.SAL <= S.HISAL)
LEFT OUTER JOIN EMP e2 
	ON
	(E1.MGR = E2.EMPNO)
;

SELECT SAL
FROM EMP E
WHERE E.ENAME = 'SMITH'
;

SELECT * FROM EMP WHERE HIREDATE <(SELECT HIREDATE FROM EMP WHERE ENAME = 'CLARK');

SELECT E1.EMPNO
		, E1.ENAME
		, E1.JOB
		, E1.SAL
		, D.DEPTNO
		, D.DNAME
		, D.LOC
FROM EMP e1, DEPT d
WHERE E1.DEPTNO = D.DEPTNO 
		AND E1.DEPTNO = 20
		AND E1.SAL > (SELECT AVG(SAL) FROM EMP)
;

-- 다중행 서브 쿼리 - 쿼리 안에 쿼리 문장을 사용
-- SELECT 쿼리의 결과는 --> 2개 이상의 값으로 된 테이블

-- 특정 부서에 소속된 직원
SELECT DEPTNO, ENAME , SAL
FROM EMP e
WHERE DEPTNO IN(10, 30);

-- 부서별 최고 급여에 해당하는 직원을 조회하여 출력
SELECT DEPTNO, ENAME, SAL
FROM EMP
WHERE SAL IN (SELECT MAX(SAL)
				FROM EMP 
				GROUP BY DEPTNO)
;

-- 평균 급여보다 높은 급여에 해당하는 직원을 조회하여 출력
SELECT *
FROM EMP e, DEPT d 
WHERE E.DEPTNO = D.DEPTNO
	AND E.DEPTNO = 20
	AND E.SAL > (SELECT AVG(SAL) FROM EMP)
;

-- 부서별 최대 급여
SELECT
	DEPTNO,
	MAX(SAL)    -- SUB-QUERY에 해당
FROM
	EMP e
GROUP BY
	DEPTNO
ORDER BY
	DEPTNO 
;

-- 특정 부서의 모든 사원들의 최소 급여보다 더 적게 받는 직원
SELECT *
FROM EMP
WHERE SAL < ALL (SELECT SAL FROM EMP WHERE DEPTNO =30);


-- 특정 부서 사원들의 최대 급여보다 적은 급여를 받는 직원 출력
SELECT *
FROM EMP
WHERE SAL < ANY (SELECT SAL
FROM EMP
WHERE DEPTNO = 30)
;

-- 위에 들어갈 서브쿼리
SELECT SAL
FROM EMP
WHERE DEPTNO = 30
;

SELECT MIN(SAL), MAX(SAL)
FROM EMP
WHERE SAL = ANY (SUB_QUERY)
;

-- 다중열 서브 쿼리 :: 서브 쿼리 결과가 두 개 이상의 컬럼으로 구성된 테이블 값
SELECT
	DEPTNO ,
	SAL,
	EMPNO,
	ENAME
FROM
	EMP
WHERE
	(DEPTNO ,
	SAL) 
	IN (SELECT DEPTNO, MAX(SAL)
	FROM EMP
	GROUP BY DEPTNO)
;

-- FROM 절에 사용되는 서브 쿼리
SELECT 
FROM (SELECT FROM  ) A
, (SELECT FROM  ) B
WHERE A. = B. 
-- 이렇게 틀을 잡아놓고 작성해보자

SELECT A.EMPNO
	, A.SAL
	, B.DNAME 
	, B.LOC 
FROM (SELECT * FROM EMP WHERE DEPTNO = 30) A
	, (SELECT * FROM DEPT ) B
WHERE A.DEPTNO = B.DEPTNO
;

-- WITH절 (구문) 사용 - 편리한 가상 테이블로 활용
WITH E AS ()
	, D AS ()
SELECT ....
FROM E, D
-- 틀입니다

-- WITH절로 원하는 가상 TABLE을 미리 지정 후 원하는 값을 출력 (부서번호 20, GRADE 출력) 
WITH E AS (SELECT * FROM EMP WHERE DEPTNO = 20)
	, D AS (SELECT * FROM DEPT)
	, S AS (SELECT * FROM SALGRADE)
SELECT E.ENAME
	, D.DNAME
	, E.SAL
	, D.LOC
	, S.GRADE
FROM E, D, S
WHERE E.DEPTNO = D.DEPTNO
	AND E.SAL BETWEEN S.LOSAL AND S.HISAL
;

WITH E AS (SELECT * FROM EMP WHERE DEPTNO = 20)
	, D AS (SELECT * FROM DEPT)
	, S AS (SELECT * FROM SALGRADE)
SELECT E.ENAME
	, D.DNAME
	, E.SAL
	, D.LOC
	, S.GRADE
FROM E, D, S
WHERE E.DEPTNO = D.DEPTNO
	AND E.SAL BETWEEN S.LOSAL AND S.HISAL
;

/*
 * CREATE TABLE
 */
CREATE TABLE DEPT_TEMP
	AS
SELECT
	*
FROM
	DEPT;    -- 기존 DEPT테이블을 가지고 임시 테이블을 만들었다
	
DROP TABLE DEPT_TEMP;     -- 테이블을 제거함 

 -- DML(DATA MANIPULATION LANGUAGE): SELECT, INSERT, UPDATE, DELETE   :: 조작, 처리
 -- DDL(DATA DEFINITION LANGUAGE): CREATE, ALTER, DROP, TRUNCATE  :: 테이블 구조변경
 -- COMMIT; -- TO CONFIRM IF ANY CHANGES ON DO IS VAILD







--LAG 함수: 현재 행 이전 행의 값을 가져온다.
--LEAD 함수: 현재 행 다음 행의 값을 가져온다
SELECT
	EMPNO,
	ENAME,
	JOB,
	HIREDATE,
	LAG(HIREDATE , 1) OVER (PARTITION BY JOB
ORDER BY
	HIREDATE) AS previous_hiredate,
	LEAD(HIREDATE , 1) OVER (PARTITION BY JOB
ORDER BY
	HIREDATE) AS next_hiredate
FROM
	EMP;